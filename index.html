<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planet Jumper 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #gameCanvas {
            z-index: 1; /* Used for HUD and text overlay */
            pointer-events: none; /* Let clicks pass through to 3D canvas if needed */
        }
        #threeCanvas {
            z-index: 0;
            display: block; 
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        #settings {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
        }
        p {
            margin: 0;
            font-size: 14px;
            color: #ccc;
            text-shadow: 1px 1px 2px black;
        }
        .stat-label {
            color: #88aaff;
            font-weight: bold;
            display: inline-block;
            width: 90px;
        }
        #streak-container {
            margin-top: 5px;
            font-size: 18px;
            color: #ffaa00;
            font-weight: bold;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s;
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
            animation: pulse 2s infinite;
            z-index: 10;
        }
        .key {
            display: inline-block;
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #555;
            font-family: monospace;
            font-size: 12px;
        }
        label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
        }
        input[type="checkbox"] {
            margin-right: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        input[type="range"] {
            margin-left: 10px;
            cursor: pointer;
            width: 100px;
        }
        #advancedControls {
            margin-top: 5px; 
            padding-left: 5px; 
            border-left: 2px solid #444;
            display: none;
            flex-direction: column;
            gap: 5px;
        }
        #gameOverScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: auto;
        }
        #gameOverScreen h2 { font-size: 40px; color: #ff3333; margin-bottom: 20px; }
        #gameOverScreen button {
            padding: 10px 20px; font-size: 20px; background: #00ffff; border: none; cursor: pointer; border-radius: 5px;
        }
        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }
    </style>
</head>
<body>

<div id="ui">
    <h1>PLANET JUMPER 3D</h1>
    <p><span class="stat-label">SCORE:</span> <span id="score">0</span></p>
    <p><span class="stat-label">VELOCITY:</span> <span id="vel">0</span></p>
    <p><span class="stat-label">POS:</span> <span id="coords">0, 0, 0</span></p>
    <div id="streak-container">FLYBY STREAK: <span id="streak">0</span></div>
</div>

<div id="settings">
    <label>
        <input type="checkbox" id="advancedToggle"> Advanced Mode
    </label>
    <div id="advancedControls">
        <label style="font-size:12px">
            Speed: <span id="speedVal">1.0</span>
            <input type="range" id="speedSlider" min="0.1" max="10.0" step="0.1" value="1.0">
        </label>
        <label style="font-size:12px">
            Render Dist: <span id="distVal">1800</span>
            <input type="range" id="distSlider" min="500" max="4000" step="100" value="1800">
        </label>
        <label style="font-size:12px">
            Density: <span id="densityVal">1.00</span>
            <!-- UPDATED: More precise step -->
            <input type="range" id="densitySlider" min="0" max="2" step="0.01" value="1.0">
        </label>
        <label style="font-size:12px">
            Flyby Radius: <span id="flybyVal">1.25x</span>
            <input type="range" id="flybySlider" min="1.05" max="2.0" step="0.05" value="1.25">
        </label>
    </div>
</div>

<div id="controls-hint">
    <span id="hint-text">Tap / Click to Jump</span>
    <div id="steer-hint" style="margin-top:5px; font-size: 12px; color: #00ffff;">
        Use <span class="key">←</span> <span class="key">→</span> to steer orbit
    </div>
</div>

<div id="gameOverScreen">
    <h2>MISSION FAILED</h2>
    <p style="font-size: 20px; color: white; margin-bottom: 20px;">You landed on a hazardous planet!</p>
    <button onclick="resetGameMode()">RESTART</button>
</div>

<!-- 2D Canvas is now used ONLY for HUD/Text Overlay -->
<canvas id="gameCanvas"></canvas>

<script>
// --- Math Helpers (Vector3) ---
const V3 = {
    create: (x, y, z) => ({x: x||0, y: y||0, z: z||0}),
    add: (a, b) => ({x: a.x+b.x, y: a.y+b.y, z: a.z+b.z}),
    sub: (a, b) => ({x: a.x-b.x, y: a.y-b.y, z: a.z-b.z}),
    scale: (v, s) => ({x: v.x*s, y: v.y*s, z: v.z*s}),
    dot: (a, b) => a.x*b.x + a.y*b.y + a.z*b.z,
    cross: (a, b) => ({
        x: a.y*b.z - a.z*b.y,
        y: a.z*b.x - a.x*b.z,
        z: a.x*b.y - a.y*b.x
    }),
    magSq: (v) => v.x*v.x + v.y*v.y + v.z*v.z,
    mag: (v) => Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z),
    norm: (v) => {
        const m = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
        return m === 0 ? {x:0, y:0, z:0} : {x: v.x/m, y: v.y/m, z: v.z/m};
    },
    dist: (a, b) => Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2 + (a.z-b.z)**2),
    rotate: (v, k, theta) => {
        const cos = Math.cos(theta);
        const sin = Math.sin(theta);
        const kCrossV = V3.cross(k, v);
        const kDotV = V3.dot(k, v);
        return {
            x: v.x*cos + kCrossV.x*sin + k.x*kDotV*(1-cos),
            y: v.y*cos + kCrossV.y*sin + k.y*kDotV*(1-cos),
            z: v.z*cos + kCrossV.z*sin + k.z*kDotV*(1-cos)
        };
    }
};

/**
 * Simple 3D Noise Implementation
 */
const Perlin = {
    rand: {},
    seed: function(seed) { this.rand = { seed: seed }; },
    random: function() { var x = Math.sin(this.rand.seed++) * 10000; return x - Math.floor(x); },
    fade: function(t) { return t * t * t * (t * (t * 6 - 15) + 10); },
    lerp: function(t, a, b) { return a + t * (b - a); },
    noise: function(x, y, z) {
        return this.noise2d(x + z*0.5, y - z*0.5); 
    },
    noise2d: function(x, y) {
        var X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
        x -= Math.floor(x); y -= Math.floor(y);
        var u = this.fade(x), v = this.fade(y);
        const p = (X, Y) => {
            let n = X + Y * 57; n = (n << 13) ^ n;
            return (1.0 - ((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
        };
        let aa = p(X, Y), ab = p(X, Y + 1), ba = p(X + 1, Y), bb = p(X + 1, Y + 1);
        return this.lerp(v, this.lerp(u, aa, ba), this.lerp(u, ab, bb));
    }
};

// --- Game Constants & Setup ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const velEl = document.getElementById('vel');
const coordsEl = document.getElementById('coords');
const streakContainer = document.getElementById('streak-container');
const streakEl = document.getElementById('streak');
const advancedToggle = document.getElementById('advancedToggle');
const advancedControls = document.getElementById('advancedControls');
const speedSlider = document.getElementById('speedSlider');
const speedVal = document.getElementById('speedVal');
const distSlider = document.getElementById('distSlider');
const distVal = document.getElementById('distVal');
const densitySlider = document.getElementById('densitySlider');
const densityVal = document.getElementById('densityVal');
const flybySlider = document.getElementById('flybySlider');
const flybyVal = document.getElementById('flybyVal');
const steerHint = document.getElementById('steer-hint');
const gameOverScreen = document.getElementById('gameOverScreen');

let width, height;
const GRAVITY = 0.5;
const MAX_GRAVITY_DIST = 800;
const GRID_SIZE = 400;
// Fog/Render Distance
let RENDER_DIST = 1800;
let FOG_START = 1000;
// Density & Flyby Settings
let WORLD_DENSITY = 1.0;
let FLYBY_RADIUS_MULT = 1.25;

// Game State
let planets = [];
let player;
let score = 0;
let flybyStreak = 0;
let gameTime = 0;
let inputState = { left: false, right: false };
let isGameOver = false;

// Optimization: Track last chunk to avoid spamming generation
let lastChunk = {x: -999, y: -999, z: -999};
let generatedChunks = new Set(); 

// 3D Engine Globals
let scene, camera3D, renderer3D, playerMesh3D;
let planetMeshes = new Map();
let starPoints, starGeometry;
// Smoother camera vars
let camPosSmooth = new THREE.Vector3(0,0,500);
let camLookAtSmooth = new THREE.Vector3(0,0,0);
let camUpSmooth = new THREE.Vector3(0,1,0);

// Particles & Instancing
let hexParticles;
const hexCount = 30; 
let hexData = [];
let hexDummy = new THREE.Object3D(); 

let fireParticles;
const fireCount = 300;
let fireDummy = new THREE.Object3D();
let fireData = [];

// Coins
let coinParticles;
// High capacity for coins across many planets
const MAX_COINS = 2000; 
let coinDummy = new THREE.Object3D();
let coinGeometry, coinMaterial;

// Text Burst
let floatingTexts = [];
let centralExplosions = []; // NEW: Exploding text for streaks

// Optimization: Shared Geometries
let sharedSphereGeo;

// --- CUSTOM SHADERS ---

// UPDATED: Planet Shader (8 Color Biome for smoother/richer noise maps)
const planetVertexShader = `
varying vec3 vWorldPosition;
varying vec3 vNormal;
void main() {
    vNormal = normalize(normalMatrix * normal);
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vWorldPosition = worldPosition.xyz;
    gl_Position = projectionMatrix * viewMatrix * worldPosition;
}
`;

const planetFragmentShader = `
uniform vec3 color1;
uniform vec3 color2;
uniform vec3 color3;
uniform vec3 color4;
uniform vec3 color5;
// ADDED: Extra colors for more variety
uniform vec3 color6;
uniform vec3 color7;
uniform vec3 color8;

uniform vec3 blinkColor;
uniform float blinkStrength;

// Fog Uniforms
uniform vec3 fogColor;
uniform float fogStart;
uniform float fogEnd;
uniform vec3 cameraPos; 

varying vec3 vWorldPosition;
varying vec3 vNormal;

// Fast noise function
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) { 
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 = v - i + dot(i, C.xxx) ;
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; 
  vec3 x3 = x0 - D.yyy;      
  i = mod289(i); 
  vec4 p = permute( permute( permute( 
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
  float n_ = 0.142857142857; 
  vec3  ns = n_ * D.wyz - D.xzx;
  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); 
  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );   
  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);
  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
}

float fbm(vec3 x) {
    float v = 0.0;
    float a = 0.5;
    vec3 shift = vec3(100.0);
    for (int i = 0; i < 3; ++i) {
        v += a * snoise(x);
        x = x * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

void main() {
    float n = fbm(vWorldPosition * 0.04); 
    n = n * 0.5 + 0.5; 

    vec3 finalColor;
    
    // UPDATED: 8-Color Biome Stepping logic
    // We map 0.0-1.0 range to 8 colors
    // 0.0 - 0.125 : c1-c2
    // 0.125 - 0.25: c2-c3 etc
    
    float stepSize = 0.125; // 1.0 / 8.0
    
    if (n < stepSize) {
        finalColor = mix(color1, color2, smoothstep(0.0, stepSize, n));
    } else if (n < stepSize * 2.0) {
        finalColor = mix(color2, color3, smoothstep(stepSize, stepSize * 2.0, n));
    } else if (n < stepSize * 3.0) {
        finalColor = mix(color3, color4, smoothstep(stepSize * 2.0, stepSize * 3.0, n));
    } else if (n < stepSize * 4.0) {
        finalColor = mix(color4, color5, smoothstep(stepSize * 3.0, stepSize * 4.0, n));
    } else if (n < stepSize * 5.0) {
        finalColor = mix(color5, color6, smoothstep(stepSize * 4.0, stepSize * 5.0, n));
    } else if (n < stepSize * 6.0) {
        finalColor = mix(color6, color7, smoothstep(stepSize * 5.0, stepSize * 6.0, n));
    } else if (n < stepSize * 7.0) {
        finalColor = mix(color7, color8, smoothstep(stepSize * 6.0, stepSize * 7.0, n));
    } else {
        finalColor = color8; 
    }

    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.8));
    float diff = max(dot(vNormal, lightDir), 0.0);
    float ambient = 0.2;
    
    vec3 baseCol = finalColor * (diff + ambient);
    
    // Add pulsing blink color overlay (additive)
    vec3 final = baseCol + (blinkColor * blinkStrength);

    // --- FOG / FADE LOGIC ---
    // Calculate distance from player/camera to this pixel in world space
    float dist = distance(vWorldPosition, cameraPos);
    
    // Smoothstep creates a curve from 0.0 to 1.0 between start and end
    float fogFactor = smoothstep(fogStart, fogEnd, dist);
    
    // Mix the object color with the background color based on fogFactor
    // If factor is 1.0 (far away), it's fully fogColor.
    gl_FragColor = vec4(mix(final, fogColor, fogFactor), 1.0);
}
`;

// Resize handling
function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    if (renderer3D) {
        renderer3D.setSize(width, height);
        camera3D.aspect = width / height;
        camera3D.updateProjectionMatrix();
    }
}
window.addEventListener('resize', resize);

// --- 3D Engine Setup ---
function init3D() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.Fog(0x050510, FOG_START, RENDER_DIST);

    camera3D = new THREE.PerspectiveCamera(60, width / height, 0.1, 5000);
    
    renderer3D = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer3D.setSize(width, height);
    renderer3D.domElement.id = 'threeCanvas';
    document.body.appendChild(renderer3D.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 100, 100);
    scene.add(dirLight);

    // Shared Geometries
    sharedSphereGeo = new THREE.SphereGeometry(1, 64, 64); // Smoother for noise

    // Player Mesh
    playerMesh3D = new THREE.Group();

    // Fuselage
    const fuseGeo = new THREE.CylinderGeometry(0.5, 1.5, 8, 8);
    fuseGeo.rotateX(Math.PI/2);
    const fuseMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, roughness: 0.4 });
    const fuse = new THREE.Mesh(fuseGeo, fuseMat);
    playerMesh3D.add(fuse);

    // Cockpit
    const cockGeo = new THREE.SphereGeometry(1.2, 8, 8);
    const cockMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
    const cockpit = new THREE.Mesh(cockGeo, cockMat);
    cockpit.position.set(0, 0.5, 1);
    cockpit.scale.set(1, 0.6, 1.5);
    playerMesh3D.add(cockpit);

    // Wings
    const wingGeo = new THREE.BoxGeometry(8, 0.2, 3);
    const wingMat = new THREE.MeshStandardMaterial({ color: 0x0088aa });
    const wings = new THREE.Mesh(wingGeo, wingMat);
    wings.position.set(0, 0, -1);
    playerMesh3D.add(wings);

    // Engine Glow
    const engineGeo = new THREE.CylinderGeometry(0.8, 0.5, 1, 8);
    engineGeo.rotateX(Math.PI/2);
    const engineMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    const engine = new THREE.Mesh(engineGeo, engineMat);
    engine.position.set(0, 0, -4.5);
    playerMesh3D.add(engine);

    scene.add(playerMesh3D);

    // Infinite Starfield
    starGeometry = new THREE.BufferGeometry();
    const starCount = 3000;
    const posArray = new Float32Array(starCount * 3);
    const spread = 2000;
    for(let i=0; i<starCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * spread; 
    }
    starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const starMat = new THREE.PointsMaterial({size: 3, color: 0xffffff, transparent: true, opacity: 0.6});
    starPoints = new THREE.Points(starGeometry, starMat);
    scene.add(starPoints);

    // Hexagon Ring
    const hexRadius = 2.5;
    const hexThickness = 0.5;
    const hexPts = [];
    const hexInnerPts = [];
    
    for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        hexPts.push(new THREE.Vector2(Math.cos(angle) * hexRadius, Math.sin(angle) * hexRadius));
        hexInnerPts.push(new THREE.Vector2(Math.cos(angle) * (hexRadius - hexThickness), Math.sin(angle) * (hexRadius - hexThickness)));
    }
    
    const hexShape = new THREE.Shape();
    hexShape.moveTo(hexPts[0].x, hexPts[0].y);
    for (let i = 1; i < 6; i++) hexShape.lineTo(hexPts[i].x, hexPts[i].y);
    hexShape.closePath();
    
    const hexHole = new THREE.Path();
    hexHole.moveTo(hexInnerPts[0].x, hexInnerPts[0].y);
    for (let i = 1; i < 6; i++) hexHole.lineTo(hexInnerPts[i].x, hexInnerPts[i].y);
    hexHole.closePath();
    
    const customHexGeo = new THREE.ShapeGeometry(hexShape);

    const hexMat = new THREE.MeshBasicMaterial({ 
        color: 0x00aaff, 
        transparent: true, 
        opacity: 0.8, 
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });
    hexParticles = new THREE.InstancedMesh(customHexGeo, hexMat, hexCount);
    hexParticles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    for(let i=0; i<hexCount; i++) {
        hexData.push({ life: 0, x:0, y:0, z:0, dirX:0, dirY:0, dirZ:0 });
    }
    scene.add(hexParticles);

    // Fire Particles
    const fireGeo = new THREE.PlaneGeometry(2, 2);
    const fireMat = new THREE.MeshBasicMaterial({
        color: 0xff5500,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
    });
    fireParticles = new THREE.InstancedMesh(fireGeo, fireMat, fireCount);
    fireParticles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    scene.add(fireParticles);

    for(let i=0; i<fireCount; i++) {
        fireData.push({ life: 0, x:0, y:0, z:0, vx:0, vy:0, vz:0 });
    }

    // Coin Particles
    coinGeometry = new THREE.CylinderGeometry(2, 2, 0.5, 12);
    coinGeometry.rotateX(Math.PI/2); // Face player roughly
    coinMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700 }); // Gold
    coinParticles = new THREE.InstancedMesh(coinGeometry, coinMaterial, MAX_COINS);
    coinParticles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    scene.add(coinParticles);
}

function updateCoins3D() {
    let index = 0;
    const time = Date.now() * 0.003;
    
    // Optimization: Loop through active planets, BUT skip those far away
    // This prevents calculating thousands of coin positions for invisible planets
    for (let i = 0; i < planets.length; i++) {
        const p = planets[i];
        
        // Fast distance check
        if (Math.abs(p.x - player.pos.x) > RENDER_DIST) continue; // Skip X check first
        const distSq = (p.x - player.pos.x)**2 + (p.y - player.pos.y)**2 + (p.z - player.pos.z)**2;
        
        if (distSq < RENDER_DIST * RENDER_DIST) {
            // Planet is visible, process coins
            for (let j = 0; j < p.coins.length; j++) {
                const c = p.coins[j];
                if (c.active && index < MAX_COINS) {
                     const cx = p.x + c.nx * (p.radius + 3);
                     const cy = p.y + c.ny * (p.radius + 3);
                     const cz = p.z + c.nz * (p.radius + 3);

                     coinDummy.position.set(cx, cy, cz);
                     coinDummy.lookAt(p.x, p.y, p.z);
                     coinDummy.rotateZ(time);
                     coinDummy.updateMatrix();
                     coinParticles.setMatrixAt(index, coinDummy.matrix);
                     index++;
                }
            }
        }
    }

    // Zero out remaining
    for(let i=index; i<MAX_COINS; i++) {
        coinDummy.scale.set(0,0,0);
        coinDummy.updateMatrix();
        coinParticles.setMatrixAt(i, coinDummy.matrix);
        coinDummy.scale.set(1,1,1); // Reset
    }
    coinParticles.instanceMatrix.needsUpdate = true;
}

function updateHexParticles(playerPos, currentPlanet) {
    if (!currentPlanet || player.state !== 'orbiting') {
        for (let i = 0; i < hexCount; i++) {
            hexDummy.scale.set(0,0,0);
            hexDummy.updateMatrix();
            hexParticles.setMatrixAt(i, hexDummy.matrix);
        }
        hexParticles.instanceMatrix.needsUpdate = true;
        return;
    }
    
    hexParticles.visible = true;
    for(let i=0; i<hexCount; i++) {
        const h = hexData[i];
        if (h.life <= 0) {
            if (Math.random() < 0.2) { 
                h.life = 1.0;
                h.x = playerPos.x; h.y = playerPos.y; h.z = playerPos.z;
                const dx = currentPlanet.x - playerPos.x;
                const dy = currentPlanet.y - playerPos.y;
                const dz = currentPlanet.z - playerPos.z;
                const len = Math.sqrt(dx*dx+dy*dy+dz*dz);
                h.dirX = dx/len; h.dirY = dy/len; h.dirZ = dz/len;
                const startOffset = 3.0; 
                h.x += h.dirX * startOffset;
                h.y += h.dirY * startOffset;
                h.z += h.dirZ * startOffset;
            }
        }
        if (h.life > 0) {
            h.life -= 0.03;
            const speed = 1.5;
            h.x += h.dirX * speed;
            h.y += h.dirY * speed;
            h.z += h.dirZ * speed;
            hexDummy.position.set(h.x, h.y, h.z);
            hexDummy.lookAt(currentPlanet.x, currentPlanet.y, currentPlanet.z);
            const s = (1.2 - h.life) * 4.0;
            hexDummy.scale.set(s, s, s);
            hexDummy.updateMatrix();
            hexParticles.setMatrixAt(i, hexDummy.matrix);
        } else {
             hexDummy.scale.set(0,0,0);
             hexDummy.updateMatrix();
             hexParticles.setMatrixAt(i, hexDummy.matrix);
        }
    }
    hexParticles.instanceMatrix.needsUpdate = true;
}

function updateFireParticles(player, planets) {
    if (player.state === 'orbiting') {
        fireParticles.visible = false;
        return;
    }

    let reEntry = false;
    let planet = null;
    let minDist = Infinity;
    
    // Optimized search for reentry planet
    for(let i=0; i<planets.length; i++) {
        const p = planets[i];
        if (Math.abs(p.x - player.pos.x) > 200) continue; // Optimization
        const d = V3.dist(player.pos, p);
        if (d < minDist) { minDist = d; planet = p; }
    }

    if (planet) {
        const atmRadius = planet.radius * 1.25;
        if (minDist < atmRadius && minDist > planet.radius) {
            reEntry = true;
        }
    }

    if (reEntry) {
        for(let i=0; i<5; i++) {
            const idx = Math.floor(Math.random() * fireCount);
            if (fireData[idx].life <= 0) {
                fireData[idx].life = 1.0;
                const velocityNorm = V3.magSq(player.vel) > 0.1 ? V3.norm(player.vel) : {x:0,y:0,z:0};
                const backward = V3.scale(velocityNorm, -3);
                const jitterX = (Math.random()-0.5)*2;
                const jitterY = (Math.random()-0.5)*2;
                const jitterZ = (Math.random()-0.5)*2;
                fireData[idx].x = player.pos.x + backward.x + jitterX;
                fireData[idx].y = player.pos.y + backward.y + jitterY;
                fireData[idx].z = player.pos.z + backward.z + jitterZ;
                fireData[idx].vx = (Math.random()-0.5)*0.5;
                fireData[idx].vy = (Math.random()-0.5)*0.5;
                fireData[idx].vz = (Math.random()-0.5)*0.5;
            }
        }
    }

    fireParticles.visible = reEntry || fireParticles.visible; 
    
    let anyAlive = false;
    for(let i=0; i<fireCount; i++) {
        const p = fireData[i];
        if (p.life > 0) {
            anyAlive = true;
            p.x += p.vx; p.y += p.vy; p.z += p.vz;
            p.life -= 0.05;
            fireDummy.position.set(p.x, p.y, p.z);
            fireDummy.lookAt(camera3D.position); 
            const s = p.life * 2;
            fireDummy.scale.set(s, s, s);
        } else {
            fireDummy.scale.set(0,0,0);
        }
        fireDummy.updateMatrix();
        fireParticles.setMatrixAt(i, fireDummy.matrix);
    }
    
    if (!anyAlive && !reEntry) fireParticles.visible = false;
    else fireParticles.visible = true;

    fireParticles.instanceMatrix.needsUpdate = true;
}

// --- Burst Text System ---
function createFloatingText(x, y, z, text, color = "#ffff66") {
    floatingTexts.push({ x, y, z, text, life: 1.0, offset: 0, color: color });
}

function updateFloatingTexts() {
    // Normal floating texts
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.life -= 0.015;
        t.offset += 1; // Rise up
        if (t.life <= 0) floatingTexts.splice(i, 1);
    }
    
    // Central Explosion texts
    for (let i = centralExplosions.length - 1; i >= 0; i--) {
        const t = centralExplosions[i];
        t.life -= 0.02; // Fade faster
        t.scale += 0.02; // Expand
        if (t.life <= 0) centralExplosions.splice(i, 1);
    }
}

function triggerExplosion(text) {
    centralExplosions.push({
        text: text,
        life: 1.0,
        scale: 1.0,
        rotation: (Math.random() - 0.5) * 0.2
    });
}

function drawFloatingTexts(ctx, camX, camY) {
    ctx.textAlign = "center";
    
    // 1. World Space Floating Texts
    ctx.font = "bold 20px 'Segoe UI', Arial";
    floatingTexts.forEach(t => {
        const vec = new THREE.Vector3(t.x, t.y, t.z);
        vec.project(camera3D);
        
        // Check if point is roughly in front of camera
        if (vec.z < 1) {
            const sx = (vec.x * 0.5 + 0.5) * width;
            const sy = (-(vec.y * 0.5) + 0.5) * height;

            ctx.globalAlpha = Math.max(0, t.life);
            ctx.fillStyle = t.color;
            ctx.strokeStyle = `rgba(0, 0, 0, ${t.life})`;
            ctx.lineWidth = 4;
            ctx.strokeText(t.text, sx, sy - t.offset);
            ctx.fillText(t.text, sx, sy - t.offset);
            ctx.globalAlpha = 1.0;
        }
    });

    // 2. Screen Space Exploding Texts
    centralExplosions.forEach(t => {
        ctx.save();
        ctx.translate(width/2, height/2);
        ctx.rotate(t.rotation);
        ctx.scale(t.scale, t.scale);
        
        const fontSize = 40 + (1.0 - t.life) * 10;
        ctx.font = `900 ${fontSize}px 'Segoe UI', Arial`;
        
        ctx.globalAlpha = t.life;
        ctx.fillStyle = "#ffaa00";
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.shadowColor = "rgba(255, 170, 0, 0.8)";
        ctx.shadowBlur = 20;
        
        ctx.strokeText(t.text, 0, 0);
        ctx.fillText(t.text, 0, 0);
        
        ctx.restore();
    });
}


function updateVisuals3D() {
    let visualPos = { x: player.pos.x, y: player.pos.y, z: player.pos.z };
    
    if (player.state === 'orbiting' && player.currentPlanet) {
        const p = player.currentPlanet;
        const normal = V3.norm(V3.sub(player.pos, p));
        visualPos = V3.add(p, V3.scale(normal, p.radius + 1.5));
    }

    playerMesh3D.position.set(visualPos.x, visualPos.y, visualPos.z);
    
    let forward = V3.norm(player.vel);
    if (V3.magSq(player.vel) < 0.1) forward = V3.create(1, 0, 0); 
    
    let up = V3.create(0, 0, 1);
    if (player.state === 'orbiting' && player.currentPlanet) {
        up = V3.norm(V3.sub(player.pos, player.currentPlanet));
    } else {
        let closest = null; let minD = Infinity;
        // Optimization: only search near planets for camera orient
        for(let i=0; i<planets.length; i++) {
             const p = planets[i];
             if (Math.abs(p.x - player.pos.x) > 300) continue;
             const d = V3.dist(p, player.pos); 
             if(d<minD){minD=d; closest=p;}
        }

        if(closest && minD < MAX_GRAVITY_DIST) {
            up = V3.norm(V3.sub(player.pos, closest));
        }
    }
    
    const targetM = new THREE.Matrix4();
    targetM.lookAt(
        new THREE.Vector3(0,0,0), 
        new THREE.Vector3(forward.x, forward.y, forward.z), 
        new THREE.Vector3(up.x, up.y, up.z)
    );
    const targetQ = new THREE.Quaternion();
    targetQ.setFromRotationMatrix(targetM);
    playerMesh3D.quaternion.slerp(targetQ, 0.04); 

    let idealOffset;
    let idealLookAt = player.pos;

    if (player.state === 'orbiting' && player.currentPlanet) {
         const pNormal = V3.norm(V3.sub(player.pos, player.currentPlanet));
         const backVec = V3.scale(forward, -100);
         const upVec = V3.scale(pNormal, 60);
         idealOffset = V3.add(player.pos, V3.add(backVec, upVec));
         camUpSmooth.lerp(new THREE.Vector3(pNormal.x, pNormal.y, pNormal.z), 0.01);

    } else {
        const backVec = V3.scale(forward, -120);
        const camUpV3 = {x: camUpSmooth.x, y: camUpSmooth.y, z: camUpSmooth.z}; 
        const upVec = V3.scale(camUpV3, 60); 
        idealOffset = V3.add(player.pos, V3.add(backVec, upVec));
        
        let closest = null; let minD = Infinity;
        for(let i=0; i<planets.length; i++) {
             const p = planets[i];
             if (Math.abs(p.x - player.pos.x) > 300) continue;
             const d = V3.dist(p, player.pos); 
             if(d<minD){minD=d; closest=p;}
        }
        
        if(closest && minD < MAX_GRAVITY_DIST) {
             const pNormal = V3.norm(V3.sub(player.pos, closest));
             camUpSmooth.lerp(new THREE.Vector3(pNormal.x, pNormal.y, pNormal.z), 0.005);
        } else {
             camUpSmooth.lerp(new THREE.Vector3(0,1,0), 0.005);
        }
    }
    
    let idealV3 = new THREE.Vector3(idealOffset.x, idealOffset.y, idealOffset.z);
    camPosSmooth.lerp(idealV3, 0.05); 
    camLookAtSmooth.lerp(new THREE.Vector3(idealLookAt.x, idealLookAt.y, idealLookAt.z), 0.05); 

    // Camera Collision - Optimized loop
    for(let i=0; i<planets.length; i++) {
        const p = planets[i];
        if (Math.abs(p.x - player.pos.x) > 300) continue; 
        
        const center = new THREE.Vector3(p.x, p.y, p.z);
        const dist = camPosSmooth.distanceTo(center);
        const buffer = 20;
        if (dist < p.radius + buffer) {
            const normal = new THREE.Vector3().subVectors(camPosSmooth, center).normalize();
            camPosSmooth.copy(center.add(normal.multiplyScalar(p.radius + buffer)));
        }
    }

    camera3D.position.copy(camPosSmooth);
    camera3D.up.copy(camUpSmooth);
    camera3D.lookAt(camLookAtSmooth);

    const positions = starPoints.geometry.attributes.position.array;
    const spread = 2000;
    const halfSpread = spread / 2;
    for (let i = 0; i < positions.length; i += 3) {
        let x = positions[i]; let y = positions[i+1]; let z = positions[i+2];
        const dx = player.pos.x - x; const dy = player.pos.y - y; const dz = player.pos.z - z;
        if (dx > halfSpread) positions[i] += spread; if (dx < -halfSpread) positions[i] -= spread;
        if (dy > halfSpread) positions[i+1] += spread; if (dy < -halfSpread) positions[i+1] -= spread;
        if (dz > halfSpread) positions[i+2] += spread; if (dz < -halfSpread) positions[i+2] -= spread;
    }
    starPoints.geometry.attributes.position.needsUpdate = true;
    
    updateHexParticles(player.pos, player.currentPlanet);
    updateFireParticles(player, planets);
    updateCoins3D();

    const time = Date.now() * 0.005;
    const blinkVal = (Math.sin(time) + 1.0) * 0.5;

    // Prune distant meshes from the map
    for (let [p, mesh] of planetMeshes) {
        if (V3.dist(p, player.pos) > RENDER_DIST + 200) { 
            scene.remove(mesh);
            planetMeshes.delete(p);
        }
    }

    // Add new meshes for visible planets
    for(let i=0; i<planets.length; i++) {
        const p = planets[i];
        if (Math.abs(p.x - player.pos.x) > RENDER_DIST) continue; // Early exit
        const distSq = (p.x-player.pos.x)**2 + (p.y-player.pos.y)**2 + (p.z-player.pos.z)**2;
        
        if (distSq < RENDER_DIST * RENDER_DIST) {
            if (!planetMeshes.has(p)) {
                const group = new THREE.Group();
                group.position.set(p.x, p.y, p.z);
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        color1: { value: new THREE.Color(p.colors[0]) },
                        color2: { value: new THREE.Color(p.colors[1]) },
                        color3: { value: new THREE.Color(p.colors[2]) },
                        color4: { value: new THREE.Color(p.colors[3]) },
                        color5: { value: new THREE.Color(p.colors[4]) },
                        // ADDED: Extra color uniforms
                        color6: { value: new THREE.Color(p.colors[5]) },
                        color7: { value: new THREE.Color(p.colors[6]) },
                        color8: { value: new THREE.Color(p.colors[7]) },
                        
                        blinkColor: { value: new THREE.Color(0,0,0) },
                        blinkStrength: { value: 0.0 },
                        fogColor: { value: new THREE.Color(0x050510) },
                        fogStart: { value: FOG_START },
                        fogEnd: { value: RENDER_DIST },
                        cameraPos: { value: new THREE.Vector3() } 
                    },
                    vertexShader: planetVertexShader,
                    fragmentShader: planetFragmentShader
                });
                const sphereMesh = new THREE.Mesh(sharedSphereGeo, mat);
                sphereMesh.scale.set(p.radius, p.radius, p.radius);
                group.add(sphereMesh);
                scene.add(group);
                planetMeshes.set(p, group);
            }
            
            // Update Uniforms
            const meshGroup = planetMeshes.get(p);
            const mesh = meshGroup.children[0];
            if (mesh && mesh.material.uniforms) {
                mesh.material.uniforms.cameraPos.value.copy(camera3D.position);
                mesh.material.uniforms.fogStart.value = FOG_START;
                mesh.material.uniforms.fogEnd.value = RENDER_DIST;

                if (p.specialType === 'trap') {
                    mesh.material.uniforms.blinkColor.value.setHex(0xff0000);
                    mesh.material.uniforms.blinkStrength.value = blinkVal * 0.8;
                } else if (p.specialType === 'bonus') {
                    mesh.material.uniforms.blinkColor.value.setHex(0x00ff00);
                    mesh.material.uniforms.blinkStrength.value = blinkVal * 0.8;
                } else {
                    mesh.material.uniforms.blinkStrength.value = 0.0;
                }
            }
        }
    }
    
    renderer3D.render(scene, camera3D);
}

// --- Classes ---

// UPDATED: Predefined Vivid Palettes
const VIBRANT_PALETTES = [
    [0xEF476F, 0xFFD166, 0x06D6A0, 0x118AB2, 0x073B4C], // Tropical
    [0x264653, 0x2A9D8F, 0xE9C46A, 0xF4A261, 0xE76F51], // Warm Earth
    [0x003049, 0xD62828, 0xF77F00, 0xFCBF49, 0xEAE2B7], // Retro
    [0xFFBE0B, 0xFB5607, 0xFF006E, 0x8338EC, 0x3A86FF], // Neon
    [0x9B5DE5, 0xF15BB5, 0xFEE440, 0x00BBF9, 0x00F5D4], // Cyber
    [0x001219, 0x005F73, 0x0A9396, 0x94D2BD, 0xE9D8A6], // Deep Ocean
    [0x1B263B, 0x415A77, 0x778DA9, 0xE0E1DD, 0xFFFFFF], // Ice
    [0x3F37C9, 0x4361EE, 0x4895EF, 0x4CC9F0, 0x7209B7], // Blue/Purple
    [0xFF595E, 0xFFCA3A, 0x8AC926, 0x1982C4, 0x6A4C93]  // Rainbow
];

class Planet {
    constructor(x, y, z, radius, type) {
        this.x = x; this.y = y; this.z = z;
        this.radius = radius;
        this.mass = radius * radius * 0.5;
        
        // ADDED: "0-3 extra colors" logic
        // Standard is 5. We allow up to 8.
        const extraColors = Math.floor(Math.random() * 4); // 0, 1, 2, or 3
        const totalColors = 5 + extraColors;
        
        this.colors = this.generateBiomeColors(totalColors); 
        this.visited = false;
        this.passed = false; // For flyby logic
        this.specialType = 'none'; // 'none', 'trap', 'bonus'
        this.coins = this.generateCoins();
    }
    
    // UPDATED: Use predefined palettes instead of random generation
    generateBiomeColors(count) {
        // Pick random palette
        const palette = VIBRANT_PALETTES[Math.floor(Math.random() * VIBRANT_PALETTES.length)];
        const resultColors = [];
        
        // We need 'count' distinct colors for the planet, derived from the palette.
        // If palette is smaller than count, we cycle or interpolate.
        // We also want to map this to exactly 8 slots for the shader.
        
        // 1. Generate 'count' distinct colors from palette
        const generated = [];
        for (let i = 0; i < count; i++) {
            // Simple cycle for now, maybe add slight noise later
            const baseHex = palette[i % palette.length];
            const c = new THREE.Color(baseHex);
            
            // Add slight randomness so planets with same palette look different
            c.offsetHSL(0, (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1);
            generated.push(c.getStyle());
        }
        
        // 2. Fill the 8 shader slots
        // If we have 5 colors, slots 1-5 are unique.
        // Slots 6,7,8 should probably just repeat the last color (highest elevation)
        // so the top of the mountain is solid.
        for (let i = 0; i < 8; i++) {
            if (i < generated.length) {
                resultColors.push(generated[i]);
            } else {
                resultColors.push(generated[generated.length - 1]);
            }
        }
        return resultColors;
    }

    generateCoins() {
        const coins = [];
        const numPoints = 4000; 
        const phi = Math.PI * (3.0 - Math.sqrt(5.0));

        for (let i = 0; i < numPoints; i++) {
            if (Math.random() < (1.0/500.0)) {
                const y = 1 - (i / (numPoints - 1)) * 2;
                const radiusAtY = Math.sqrt(1 - y * y);
                const theta = phi * i;
                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;
                
                coins.push({ nx: x, ny: y, nz: z, active: true });
            }
        }
        return coins;
    }
}

class Player {
    constructor() {
        this.width = 12;
        this.height = 16;
        this.reset();
    }

    reset() {
        this.state = 'orbiting'; 
        this.currentPlanet = null; 
        this.lastPlanet = null;
        this.jumpCooldown = 0;
        this.runSpeed = 4.0;
        this.pos = V3.create(0, 0, 0);
        this.vel = V3.create(0, 0, 0);
        this.orbitAxis = V3.create(0, 0, 1);
        this.jumpStartPos = null;
        // Flyby tracking: Map planet -> minDistanceSeen
        this.flybyTracker = new Map();
    }

    update() {
        if (this.jumpCooldown > 0) this.jumpCooldown--;
        if (this.state === 'orbiting') this.updateOrbit();
        else this.updateFlight();
    }

    updateOrbit() {
        if (!this.currentPlanet) return;
        const p = this.currentPlanet;

        const normal = V3.norm(V3.sub(this.pos, p));
        const steerSpeed = 0.03;
        if (inputState.left) this.orbitAxis = V3.norm(V3.rotate(this.orbitAxis, normal, steerSpeed));
        if (inputState.right) this.orbitAxis = V3.norm(V3.rotate(this.orbitAxis, normal, -steerSpeed));

        const omega = this.runSpeed / p.radius;
        const relPos = V3.sub(this.pos, p);
        const newRelPos = V3.rotate(relPos, this.orbitAxis, omega);
        this.pos = V3.add(p, newRelPos);
        
        const normal2 = V3.norm(newRelPos);
        const tangent = V3.norm(V3.cross(this.orbitAxis, normal2));
        this.vel = V3.scale(tangent, this.runSpeed);

        this.checkCoins(p);
    }

    updateFlight() {
        let gravity = V3.create(0, 0, 0);

        // Track closest distance to planets in range
        const currentFrameNearPlanets = new Set();
        
        // Optimize gravity loop to only nearby planets
        // Since planets is sorted by creation (roughly Z), we could optimize, 
        // but spatial filter is safer.
        for(let i=0; i<planets.length; i++) {
            const p = planets[i];
            
            // Optimization: Skip very far planets
            if (Math.abs(p.x - this.pos.x) > MAX_GRAVITY_DIST) continue;
            
            // Ignore gravity of just-left planet for short duration
            if (this.jumpCooldown > 0 && p === this.lastPlanet) continue;

            const dist = V3.dist(p, this.pos);
            if (dist < MAX_GRAVITY_DIST) {
                // Gravity
                const fMag = (GRAVITY * p.mass) / (dist*dist);
                const dir = V3.norm(V3.sub(p, this.pos));
                gravity = V3.add(gravity, V3.scale(dir, fMag));
                
                // Land?
                if (dist < p.radius + 1.0) this.land(p);

                // Coin Collection in flight (allow skimming)
                if (dist < p.radius + 10) this.checkCoins(p);

                // Flyby Tracking
                if (p !== this.lastPlanet && !p.visited && !p.passed) {
                    currentFrameNearPlanets.add(p);
                    
                    const currentMin = this.flybyTracker.get(p) || Infinity;
                    if (dist < currentMin) {
                        this.flybyTracker.set(p, dist);
                    }
                }
            }
        }

        // Check for completed flybys
        for (let [p, minDist] of this.flybyTracker) {
            if (!currentFrameNearPlanets.has(p)) {
                // We left the gravity well
                // Check if we met the criteria (Flyby Radius Slider)
                const threshold = p.radius * FLYBY_RADIUS_MULT;
                if (minDist < threshold) {
                    this.completeFlyby(p);
                }
                // Stop tracking this planet
                this.flybyTracker.delete(p);
            }
        }
        
        // Remove tracking for planets that are no longer relevant but weren't "finished" properly
        // (Clean up planets that disappeared or we teleported away from)
        for (let [p, minDist] of this.flybyTracker) {
            if (V3.dist(p, this.pos) > MAX_GRAVITY_DIST * 1.5) {
                this.flybyTracker.delete(p);
            }
        }

        this.vel = V3.add(this.vel, gravity);
        this.pos = V3.add(this.pos, this.vel);
    }

    checkCoins(planet) {
        planet.coins.forEach(c => {
            if (c.active) {
                const cx = planet.x + c.nx * (planet.radius + 3);
                const cy = planet.y + c.ny * (planet.radius + 3);
                const cz = planet.z + c.nz * (planet.radius + 3);
                
                // Coin hit radius ~4 units
                if ((this.pos.x-cx)**2 + (this.pos.y-cy)**2 + (this.pos.z-cz)**2 < 16) {
                    c.active = false;
                    score += 1000;
                    scoreEl.innerText = score;
                    createFloatingText(cx, cy, cz, "+1000", "#ffd700");
                }
            }
        });
    }

    completeFlyby(p) {
        if (p.passed) return;
        p.passed = true;
        flybyStreak++;
        updateStreakUI();
        createFloatingText(p.x, p.y + p.radius + 20, p.z, "CLOSE CALL! x" + flybyStreak, "#ffaa00");
        
        // UPDATED: Trigger huge explosion text on screen
        if (flybyStreak > 1) {
            triggerExplosion(`STREAK x${flybyStreak}!`);
        } else {
            triggerExplosion("NICE FLYBY!");
        }
    }

    jump() {
        if (this.state !== 'orbiting' || !this.currentPlanet) return;
        
        this.jumpStartPos = { ...this.pos };
        this.lastPlanet = this.currentPlanet;
        this.jumpCooldown = 60; 

        const normal = V3.norm(V3.sub(this.pos, this.currentPlanet));
        
        let tangent;
        if (V3.magSq(this.vel) > 0.01) {
             tangent = V3.norm(this.vel);
        } else {
             tangent = V3.norm(V3.cross(this.orbitAxis, normal));
        }
        
        const burstSpeed = 12.0; 
        const jumpVec = V3.scale(tangent, this.runSpeed + burstSpeed);
        
        this.vel = jumpVec;
        this.pos = V3.add(this.pos, V3.scale(normal, 5.0));

        this.state = 'flying';
        this.currentPlanet = null;
        this.flybyTracker.clear();
    }

    land(planet) {
        if (planet.specialType === 'trap') {
            gameOverScreen.style.display = 'flex';
            isGameOver = true;
            return;
        }

        this.state = 'orbiting';
        this.currentPlanet = planet;
        this.lastPlanet = null;
        this.jumpCooldown = 0;
        this.flybyTracker.clear();
        
        // Reset Streak on land
        if (flybyStreak > 0) {
            createFloatingText(this.pos.x, this.pos.y, this.pos.z, "STREAK ENDED", "#aaaaaa");
        }
        flybyStreak = 0;
        updateStreakUI();
        
        assignPlanetTypes(planet);
        
        const normal = V3.norm(V3.sub(this.pos, planet));
        let tangent = V3.norm(this.vel);
        if (V3.magSq(tangent) === 0) tangent = V3.create(1, 0, 0);
        
        this.orbitAxis = V3.norm(V3.cross(normal, tangent));
        this.pos = V3.add(planet, V3.scale(normal, planet.radius + 0.1));
        
        const correctedTangent = V3.norm(V3.cross(this.orbitAxis, normal));
        this.vel = V3.scale(correctedTangent, this.runSpeed);

        if (!planet.visited) {
            let points = 100;
            if (this.jumpStartPos) {
                const dist = V3.dist(this.pos, this.jumpStartPos);
                points = Math.floor(dist);
            }
            if (planet.specialType === 'bonus') {
                points *= 2;
                createFloatingText(this.pos.x, this.pos.y, this.pos.z, "BONUS! +" + points, "#00ff00");
                triggerExplosion("BONUS PLANET!");
            } else {
                createFloatingText(this.pos.x, this.pos.y, this.pos.z, "+" + points);
            }
            score += points;
            scoreEl.innerText = score;
            planet.visited = true;
        }
    }
}

function updateStreakUI() {
    streakEl.innerText = flybyStreak;
    if (flybyStreak > 0) {
        streakContainer.style.opacity = 1;
        streakContainer.style.transform = `scale(${1 + Math.min(flybyStreak * 0.1, 0.5)})`;
    } else {
        streakContainer.style.opacity = 0;
        streakContainer.style.transform = "scale(1)";
    }
}

// --- Gameplay Logic: Traps & Bonuses ---
function assignPlanetTypes(currentP) {
    planets.forEach(p => p.specialType = 'none');
    const candidates = planets.filter(p => p !== currentP && V3.dist(p, currentP) < 2500);
    candidates.sort(() => Math.random() - 0.5);
    for(let i=0; i<3 && i<candidates.length; i++) candidates[i].specialType = 'trap';
    if (candidates.length > 3) candidates[3].specialType = 'bonus';
}

// --- Procedural Generation ---

function getChunkId(gx, gy, gz) { return `${gx},${gy},${gz}`; }

function generateWorld(px, py, pz) {
    const gx = Math.floor(px / GRID_SIZE);
    const gy = Math.floor(py / GRID_SIZE);
    const gz = Math.floor(pz / GRID_SIZE);

    if (gx === lastChunk.x && gy === lastChunk.y && gz === lastChunk.z) return;
    lastChunk = {x: gx, y: gy, z: gz};

    // Render distance (chunks) - Dynamic based on slider? 
    // We can just keep generation distance slightly larger than max render distance
    const rad = 5; 
    const zMin = gz - rad;
    const zMax = gz + rad;

    for (let x = gx - rad; x <= gx + rad; x++) {
        for (let y = gy - rad; y <= gy + rad; y++) {
            for (let z = zMin; z <= zMax; z++) {
                const id = getChunkId(x, y, z);
                if (!generatedChunks.has(id)) {
                    generateChunk(x, y, z);
                    generatedChunks.add(id);
                }
            }
        }
    }
}

function generateChunk(gx, gy, gz) {
    const scale = 0.1;
    const noiseVal = Perlin.noise(gx * scale, gy * scale, gz * scale);
    const seed = gx * 123 + gy * 456 + gz * 789;
    
    // Increased randomness factor
    const rnd1 = Math.abs(Math.sin(seed));
    const rnd2 = Math.abs(Math.cos(seed * 2.5));

    // Variable Density Modified by Slider
    const densityNoise = Math.sin(gx * 0.2) * Math.cos(gz * 0.2); 
    // Base threshold was ~0.15. Lower threshold = more planets.
    // Slider (0 to 2, default 1). Higher slider = More planets = LOWER threshold.
    // Inverse relationship logic:
    // Slider 1.0 -> modifier 0. 
    // Slider 2.0 -> modifier -0.2 (more dense)
    // Slider 0.0 -> modifier +0.2 (less dense)
    const sliderMod = (1.0 - WORLD_DENSITY) * 0.3;
    const threshold = 0.15 + (densityNoise * 0.1) + sliderMod; 

    if (noiseVal > threshold || (rnd1 > 0.8)) {
        const cx = gx * GRID_SIZE + GRID_SIZE / 2;
        const cy = gy * GRID_SIZE + GRID_SIZE / 2;
        const cz = gz * GRID_SIZE + GRID_SIZE / 2;
        
        const offsetRange = GRID_SIZE * 0.9;
        const ox = (rnd1 - 0.5) * offsetRange;
        const oy = (rnd2 - 0.5) * offsetRange;
        const oz = (Math.sin(seed * 3) * 0.5) * offsetRange;

        let px = cx + ox;
        let py = cy + oy;
        let pz = cz + oz;
        
        let radius = 15 + (rnd1 * rnd2 * 140) + (Math.abs(noiseVal) * 40);

        if (gx === 0 && gy === 0 && gz === 0) {
            px=0; py=0; pz=0; radius=60;
        }

        let overlaps = false;
        const safeBuffer = 50; 
        
        for(let i=planets.length - 1; i >= 0; i--) {
            const other = planets[i];
            if (Math.abs(px - other.x) > 500) continue; 

            const distSq = (px-other.x)**2 + (py-other.y)**2 + (pz-other.z)**2;
            const minDist = radius + other.radius + safeBuffer;
            if (distSq < minDist * minDist) {
                overlaps = true;
                break;
            }
        }
        
        if (!overlaps) {
            const p = new Planet(px, py, pz, radius, noiseVal);
            if (gx===0 && gy===0 && gz===0) p.visited = true;
            planets.push(p);
        }
    }
}

// --- OPTIMIZATION: World Cleanup ---
let lastCleanupTime = 0;
function cleanupWorld() {
    // Only run every ~60 frames or so (called in update)
    // Remove planets that are far behind the player (beyond render dist * 1.5)
    // We assume the player moves generally in one direction or explores locally.
    // If we delete a planet and the player goes back, it needs to regenerate.
    // However, since seed is deterministic, simple regeneration works if we clear the chunk from "generatedChunks".
    
    const removalDistSq = (RENDER_DIST * 1.5) ** 2;
    const playerPos = player.pos;

    // Filter planets in place or create new array
    // Creating new array is cleaner
    const keepPlanets = [];
    
    for(let i=0; i<planets.length; i++) {
        const p = planets[i];
        
        // Always keep the planet we are on or just left
        if (p === player.currentPlanet || p === player.lastPlanet) {
            keepPlanets.push(p);
            continue;
        }

        const distSq = (p.x - playerPos.x)**2 + (p.y - playerPos.y)**2 + (p.z - playerPos.z)**2;
        
        if (distSq < removalDistSq) {
            keepPlanets.push(p);
        } else {
            // Planet is removed. We should allow its chunk to regenerate if we return.
            // Calculate chunk ID
            const gx = Math.floor(p.x / GRID_SIZE);
            const gy = Math.floor(p.y / GRID_SIZE);
            const gz = Math.floor(p.z / GRID_SIZE);
            const id = getChunkId(gx, gy, gz);
            
            // It's safe to delete from set even if other planets are in it, 
            // because generateChunk checks collisions/density again anyway if called.
            // But to avoid re-generating immediately if we are on the edge, we only delete if VERY far.
            // Actually, simply removing from 'planets' is enough to free memory.
            // If we go back, 'generateWorld' will see the chunk ID is present and NOT regen.
            // So we MUST delete from generatedChunks if we want it to reappear.
            generatedChunks.delete(id);
            
            // Also ensure visuals are gone (handled in updateVisuals3D but good to be sure)
            if (planetMeshes.has(p)) {
                scene.remove(planetMeshes.get(p));
                planetMeshes.delete(p);
            }
        }
    }
    
    planets = keepPlanets;
}

// --- Main Loop ---

function init() {
    resize();
    init3D();
    player = new Player();
    resetGameMode();
    loop();
}

function resetGameMode() {
    isGameOver = false;
    gameOverScreen.style.display = 'none';
    score = 0;
    flybyStreak = 0;
    scoreEl.innerText = 0;
    updateStreakUI();
    centralExplosions = [];
    
    planets = [];
    generatedChunks.clear();
    lastChunk = {x: -999, y: -999, z: -999}; 
    
    planetMeshes.forEach(mesh => scene.remove(mesh));
    planetMeshes.clear();
    
    player.reset();
    
    document.getElementById('threeCanvas').style.display = 'block';
    document.getElementById('gameCanvas').style.display = 'block'; 
    steerHint.style.display = 'block';
    
    // Updated default speed
    player.runSpeed = 1.0;
    speedSlider.value = 1.0;
    speedVal.innerText = 1.0;
    
    camPosSmooth.set(0,0,500);
    camUpSmooth.set(0,1,0);

    generateWorld(0, 0, 0);

    if (planets.length === 0) planets.push(new Planet(0,0,0, 60, 0.5));
    
    let bestP = null;
    let minDst = Infinity;
    planets.forEach(p => {
        const d = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
        if (d < minDst) { minDst = d; bestP = p; }
    });

    if (bestP) {
        player.pos = V3.create(bestP.x, bestP.y - bestP.radius - 10, bestP.z);
        player.land(bestP);
        player.updateOrbit();
    }
}

advancedToggle.addEventListener('change', () => {
    advancedControls.style.display = advancedToggle.checked ? 'flex' : 'none';
});
speedSlider.addEventListener('input', () => {
    player.runSpeed = parseFloat(speedSlider.value);
    speedVal.innerText = speedSlider.value;
});
distSlider.addEventListener('input', () => {
    RENDER_DIST = parseFloat(distSlider.value);
    FOG_START = RENDER_DIST * 0.6;
    distVal.innerText = distSlider.value;
    if (scene && scene.fog) {
        scene.fog.far = RENDER_DIST;
        scene.fog.near = FOG_START;
    }
});
densitySlider.addEventListener('input', () => {
    // UPDATED: Precision 0.01
    const val = parseFloat(densitySlider.value);
    WORLD_DENSITY = val;
    // Show 2 decimals
    densityVal.innerText = val.toFixed(2);
});
flybySlider.addEventListener('input', () => {
    FLYBY_RADIUS_MULT = parseFloat(flybySlider.value);
    flybyVal.innerText = FLYBY_RADIUS_MULT + "x";
});


function update() {
    if (isGameOver) return;
    
    gameTime++;
    player.update();
    generateWorld(player.pos.x, player.pos.y, player.pos.z);
    
    // Run cleanup every 100 frames
    if (gameTime % 100 === 0) cleanupWorld();
    
    velEl.innerText = Math.round(V3.mag(player.vel));
    coordsEl.innerText = `${Math.round(player.pos.x)}, ${Math.round(player.pos.y)}, ${Math.round(player.pos.z)}`;

    updateFloatingTexts();
    updateVisuals3D();
}

function drawHUD() {
    ctx.clearRect(0, 0, width, height);
    drawFloatingTexts(ctx, 0, 0);
}

function handleJump() {
    if (isGameOver) return;
    if (player.state === 'orbiting') player.jump();
}

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') handleJump();
    if (e.code === 'ArrowLeft') inputState.left = true;
    if (e.code === 'ArrowRight') inputState.right = true;
});

window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft') inputState.left = false;
    if (e.code === 'ArrowRight') inputState.right = false;
});

window.addEventListener('mousedown', (e) => {
    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') handleJump();
});

window.addEventListener('touchstart', (e) => {
    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
        e.preventDefault();
        handleJump();
    }
}, {passive: false});

function loop() {
    update();
    drawHUD();
    requestAnimationFrame(loop);
}

init();

</script>
</body>
</html>
